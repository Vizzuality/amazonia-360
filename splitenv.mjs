
import fs from 'fs';
import path from 'path';

// Usage: node splitenv.js <input-file> <prefix1> [prefix2] [...]
const args = process.argv.slice(2);
if (args.length < 2) {
    console.error(`Usage: node ${path.basename(process.argv[1])} <input-file> <prefix...>`);
    process.exit(1);
}

const [inputFile, ...prefixes] = args;
const baseDir = path.dirname(inputFile);

// Map each prefix to its suffix (stripping trailing underscores)
const prefixToSuffix = prefixes.reduce((acc, prefix) => {
    acc[prefix] = prefix.replace(/_+$/, '');
    return acc;
}, {});

// Prepare containers for each output group
const groupEntries = Object.values(prefixToSuffix).reduce((acc, suffix) => {
    acc[suffix] = [];
    return acc;
}, {});

// Read the input .env file
let content;
try {
    content = fs.readFileSync(inputFile, 'utf-8');
} catch (err) {
    console.error(`Error reading file '${inputFile}':`, err.message);
    process.exit(1);
}

// Split into lines
const rawLines = content.split(/\r?\n/);

// Merge multi-line values (quoted values spanning lines)
const mergedLines = [];
let inMultiline = false;
let multilineBuffer = '';
let currentQuote = null;

rawLines.forEach(line => {
    if (!inMultiline) {
        const match = line.match(/^([A-Za-z_][A-Za-z0-9_]*)=(.*)$/);
        if (match) {
            const rest = match[2];
            const trimmed = rest.trim();
            const startsWithQuote = trimmed.startsWith(`"`) || trimmed.startsWith(`'`);
            const quoteChar = trimmed.charAt(0);
            const endsWithQuote = trimmed.endsWith(quoteChar) && trimmed.length > 1;
            if (startsWithQuote && !endsWithQuote) {
                inMultiline = true;
                currentQuote = quoteChar;
                multilineBuffer = line;
            } else {
                mergedLines.push(line);
            }
        } else {
            // Copy non key=value lines (comments/blanks will be filtered later)
            mergedLines.push(line);
        }
    } else {
        multilineBuffer += '\n' + line;
        if (line.trim().endsWith(currentQuote)) {
            inMultiline = false;
            mergedLines.push(multilineBuffer);
            multilineBuffer = '';
            currentQuote = null;
        }
    }
});
if (inMultiline) {
    // Unterminated multiline: push anyway
    mergedLines.push(multilineBuffer);
}

// Process each logical line
mergedLines.forEach(line => {
    const trimmed = line.trim();
    // Skip blank lines and comments
    if (!trimmed || trimmed.startsWith('#')) return;

    const idx = line.indexOf('=');
    if (idx === -1) return;

    const key = line.slice(0, idx);
    const value = line.slice(idx + 1);

    // Check if the key matches any prefix
    let matched = false;
    for (const prefix of prefixes) {
        if (key.startsWith(prefix)) {
            const suffix = prefixToSuffix[prefix];
            const newKey = key.slice(prefix.length); //strip the prefix
            groupEntries[suffix].push({ key: newKey, value });
            matched = true;
            break;
        }
    }

    //  If no prefix matched, skip variables that don't match any prefix
    //  Uncomment the following lines if you want to copy unmatched variables to all groups
    if (!matched) {
        // Common variable: copy to all groups
        Object.values(prefixToSuffix).forEach(suffix => {
            groupEntries[suffix].push({ key, value });
        });
    }
});

// Write out each .env in its corresponding folder
Object.entries(groupEntries).forEach(([suffix, entries]) => {
    const dirName = suffix.toLowerCase();
    const dirPath = path.join(baseDir, dirName);

    // Ensure directory exists
    if (!fs.existsSync(dirPath) || !fs.statSync(dirPath).isDirectory()) {
        console.error(`Error: Directory '${dirPath}' for prefix '${suffix}' does not exist.`);
        process.exit(1);
    }

    const outPath = path.join(dirPath, '.env');
    const linesOut = entries.map(({ key, value }) => `${key}=${value}`);
    const contentOut = [`# file generated by splitenv.mjs from the file:///./../.env file on ${new Date()} \n`, ...linesOut].join('\n') + '\n';

    try {
        fs.writeFileSync(outPath, contentOut, 'utf-8');
        console.log(`Wrote ${outPath}`);
    } catch (err) {
        console.error(`Error writing file '${outPath}': ${err.message}`);
        process.exit(1);
    }
});
