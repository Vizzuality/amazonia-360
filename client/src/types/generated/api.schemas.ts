/**
 * Generated by orval v6.31.0 üç∫
 * Do not edit manually.
 * Amazonia360 API
 * OpenAPI spec version: 0.1.0
 */
export type ReadTableGridTablePostParams = {
  /**
   * Tile level at which the query will be computed
   */
  level: number;
  /**
   * Number of records.
   */
  limit?: number;
  /**
   * Prepend '-' to column name to make it descending
   */
  order_by: string[];
};

export type GridDatasetMetadataInAreaGridMetaPostParams = {
  /**
   * Tile level at which the query will be computed
   */
  level?: number;
  /**
   * Column/s to include in the tile. If empty, it returns only cell indexes.
   */
  columns?: string[];
};

export type GridTileInAreaGridTileTileIndexPostParams = {
  /**
   * Column/s to include in the tile. If empty, it returns only cell indexes.
   */
  columns?: string[];
};

export type GridTileGridTileTileIndexGetParams = {
  /**
   * Column/s to include in the tile. If empty, it returns only cell indexes.
   */
  columns?: string[];
};

export type TilejsonTileMatrixSetIdTilejsonJsonGetColormapName =
  (typeof TilejsonTileMatrixSetIdTilejsonJsonGetColormapName)[keyof typeof TilejsonTileMatrixSetIdTilejsonJsonGetColormapName];

export const TilejsonTileMatrixSetIdTilejsonJsonGetColormapName = {
  accent: "accent",
  accent_r: "accent_r",
  afmhot: "afmhot",
  afmhot_r: "afmhot_r",
  algae: "algae",
  algae_r: "algae_r",
  amp: "amp",
  amp_r: "amp_r",
  autumn: "autumn",
  autumn_r: "autumn_r",
  balance: "balance",
  balance_r: "balance_r",
  binary: "binary",
  binary_r: "binary_r",
  blues: "blues",
  blues_r: "blues_r",
  bone: "bone",
  bone_r: "bone_r",
  brbg: "brbg",
  brbg_r: "brbg_r",
  brg: "brg",
  brg_r: "brg_r",
  bugn: "bugn",
  bugn_r: "bugn_r",
  bupu: "bupu",
  bupu_r: "bupu_r",
  bwr: "bwr",
  bwr_r: "bwr_r",
  cfastie: "cfastie",
  cividis: "cividis",
  cividis_r: "cividis_r",
  cmrmap: "cmrmap",
  cmrmap_r: "cmrmap_r",
  cool: "cool",
  cool_r: "cool_r",
  coolwarm: "coolwarm",
  coolwarm_r: "coolwarm_r",
  copper: "copper",
  copper_r: "copper_r",
  cubehelix: "cubehelix",
  cubehelix_r: "cubehelix_r",
  curl: "curl",
  curl_r: "curl_r",
  dark2: "dark2",
  dark2_r: "dark2_r",
  deep: "deep",
  deep_r: "deep_r",
  delta: "delta",
  delta_r: "delta_r",
  dense: "dense",
  dense_r: "dense_r",
  diff: "diff",
  diff_r: "diff_r",
  flag: "flag",
  flag_r: "flag_r",
  gist_earth: "gist_earth",
  gist_earth_r: "gist_earth_r",
  gist_gray: "gist_gray",
  gist_gray_r: "gist_gray_r",
  gist_heat: "gist_heat",
  gist_heat_r: "gist_heat_r",
  gist_ncar: "gist_ncar",
  gist_ncar_r: "gist_ncar_r",
  gist_rainbow: "gist_rainbow",
  gist_rainbow_r: "gist_rainbow_r",
  gist_stern: "gist_stern",
  gist_stern_r: "gist_stern_r",
  gist_yarg: "gist_yarg",
  gist_yarg_r: "gist_yarg_r",
  gnbu: "gnbu",
  gnbu_r: "gnbu_r",
  gnuplot: "gnuplot",
  gnuplot2: "gnuplot2",
  gnuplot2_r: "gnuplot2_r",
  gnuplot_r: "gnuplot_r",
  gray: "gray",
  gray_r: "gray_r",
  greens: "greens",
  greens_r: "greens_r",
  greys: "greys",
  greys_r: "greys_r",
  haline: "haline",
  haline_r: "haline_r",
  hot: "hot",
  hot_r: "hot_r",
  hsv: "hsv",
  hsv_r: "hsv_r",
  ice: "ice",
  ice_r: "ice_r",
  inferno: "inferno",
  inferno_r: "inferno_r",
  jet: "jet",
  jet_r: "jet_r",
  magma: "magma",
  magma_r: "magma_r",
  matter: "matter",
  matter_r: "matter_r",
  nipy_spectral: "nipy_spectral",
  nipy_spectral_r: "nipy_spectral_r",
  ocean: "ocean",
  ocean_r: "ocean_r",
  oranges: "oranges",
  oranges_r: "oranges_r",
  orrd: "orrd",
  orrd_r: "orrd_r",
  oxy: "oxy",
  oxy_r: "oxy_r",
  paired: "paired",
  paired_r: "paired_r",
  pastel1: "pastel1",
  pastel1_r: "pastel1_r",
  pastel2: "pastel2",
  pastel2_r: "pastel2_r",
  phase: "phase",
  phase_r: "phase_r",
  pink: "pink",
  pink_r: "pink_r",
  piyg: "piyg",
  piyg_r: "piyg_r",
  plasma: "plasma",
  plasma_r: "plasma_r",
  prgn: "prgn",
  prgn_r: "prgn_r",
  prism: "prism",
  prism_r: "prism_r",
  pubu: "pubu",
  pubu_r: "pubu_r",
  pubugn: "pubugn",
  pubugn_r: "pubugn_r",
  puor: "puor",
  puor_r: "puor_r",
  purd: "purd",
  purd_r: "purd_r",
  purples: "purples",
  purples_r: "purples_r",
  rain: "rain",
  rain_r: "rain_r",
  rainbow: "rainbow",
  rainbow_r: "rainbow_r",
  rdbu: "rdbu",
  rdbu_r: "rdbu_r",
  rdgy: "rdgy",
  rdgy_r: "rdgy_r",
  rdpu: "rdpu",
  rdpu_r: "rdpu_r",
  rdylbu: "rdylbu",
  rdylbu_r: "rdylbu_r",
  rdylgn: "rdylgn",
  rdylgn_r: "rdylgn_r",
  reds: "reds",
  reds_r: "reds_r",
  rplumbo: "rplumbo",
  schwarzwald: "schwarzwald",
  seismic: "seismic",
  seismic_r: "seismic_r",
  set1: "set1",
  set1_r: "set1_r",
  set2: "set2",
  set2_r: "set2_r",
  set3: "set3",
  set3_r: "set3_r",
  solar: "solar",
  solar_r: "solar_r",
  spectral: "spectral",
  spectral_r: "spectral_r",
  speed: "speed",
  speed_r: "speed_r",
  spring: "spring",
  spring_r: "spring_r",
  summer: "summer",
  summer_r: "summer_r",
  tab10: "tab10",
  tab10_r: "tab10_r",
  tab20: "tab20",
  tab20_r: "tab20_r",
  tab20b: "tab20b",
  tab20b_r: "tab20b_r",
  tab20c: "tab20c",
  tab20c_r: "tab20c_r",
  tarn: "tarn",
  tarn_r: "tarn_r",
  tempo: "tempo",
  tempo_r: "tempo_r",
  terrain: "terrain",
  terrain_r: "terrain_r",
  thermal: "thermal",
  thermal_r: "thermal_r",
  topo: "topo",
  topo_r: "topo_r",
  turbid: "turbid",
  turbid_r: "turbid_r",
  turbo: "turbo",
  turbo_r: "turbo_r",
  twilight: "twilight",
  twilight_r: "twilight_r",
  twilight_shifted: "twilight_shifted",
  twilight_shifted_r: "twilight_shifted_r",
  viridis: "viridis",
  viridis_r: "viridis_r",
  winter: "winter",
  winter_r: "winter_r",
  wistia: "wistia",
  wistia_r: "wistia_r",
  ylgn: "ylgn",
  ylgn_r: "ylgn_r",
  ylgnbu: "ylgnbu",
  ylgnbu_r: "ylgnbu_r",
  ylorbr: "ylorbr",
  ylorbr_r: "ylorbr_r",
  ylorrd: "ylorrd",
  ylorrd_r: "ylorrd_r",
} as const;

export type TilejsonTileMatrixSetIdTilejsonJsonGetAlgorithm =
  (typeof TilejsonTileMatrixSetIdTilejsonJsonGetAlgorithm)[keyof typeof TilejsonTileMatrixSetIdTilejsonJsonGetAlgorithm];

export const TilejsonTileMatrixSetIdTilejsonJsonGetAlgorithm = {
  hillshade: "hillshade",
  slope: "slope",
  contours: "contours",
  normalizedIndex: "normalizedIndex",
  terrarium: "terrarium",
  terrainrgb: "terrainrgb",
  cast: "cast",
  ceil: "ceil",
  floor: "floor",
} as const;

export type TilejsonTileMatrixSetIdTilejsonJsonGetParams = {
  /**
   * Default will be automatically defined if the output image needs a mask (png) or not (jpeg).
   */
  tile_format?: ImageType | null;
  /**
   * Tile size scale. 1=256x256, 2=512x512...
   */
  tile_scale?: number;
  /**
   * Overwrite default minzoom.
   */
  minzoom?: number | null;
  /**
   * Overwrite default maxzoom.
   */
  maxzoom?: number | null;
  /**
   * Raster filename.
   */
  raster_filename: string;
  /**
   * Buffer on each side of the given tile. It must be a multiple of `0.5`. Output **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257, 1.0 = 258x258).
   */
  buffer?: number | null;
  /**
   * Padding to apply to each tile edge. Helps reduce resampling artefacts along edges. Defaults to `0`.
   */
  padding?: number | null;
  /**
   * Dataset band indexes
   */
  bidx?: number[] | null;
  /**
   * rio-tiler's band math expression
   */
  expression?: string | null;
  /**
   * Overwrite internal Nodata value
   */
  nodata?: number | number | string | null;
  /**
   * Apply internal Scale/Offset. Defaults to `False`.
   */
  unscale?: boolean | null;
  /**
   * RasterIO resampling algorithm. Defaults to `nearest`.
   */
  resampling?:
    | "nearest"
    | "bilinear"
    | "cubic"
    | "cubic_spline"
    | "lanczos"
    | "average"
    | "mode"
    | "gauss"
    | "rms"
    | null;
  /**
   * WarpKernel resampling algorithm (only used when doing re-projection). Defaults to `nearest`.
   */
  reproject?:
    | "nearest"
    | "bilinear"
    | "cubic"
    | "cubic_spline"
    | "lanczos"
    | "average"
    | "mode"
    | "sum"
    | "rms"
    | null;
  /**
   * Algorithm name
   */
  algorithm?: TilejsonTileMatrixSetIdTilejsonJsonGetAlgorithm;
  /**
   * Algorithm parameter
   */
  algorithm_params?: string | null;
  /**
   * Colormap name
   */
  colormap_name?: TilejsonTileMatrixSetIdTilejsonJsonGetColormapName;
  /**
   * JSON encoded custom Colormap
   */
  colormap?: string | null;
  /**
   * comma (',') delimited Min,Max range. Can set multiple time for multiple bands.
   */
  rescale?: string[] | null;
  /**
   * rio-color formula (info: https://github.com/mapbox/rio-color)
   */
  color_formula?: string | null;
  /**
   * Add mask to the output data. Defaults to `True`
   */
  return_mask?: boolean | null;
};

export type TileTilesTileMatrixSetIdZXYGetColormapName =
  (typeof TileTilesTileMatrixSetIdZXYGetColormapName)[keyof typeof TileTilesTileMatrixSetIdZXYGetColormapName];

export const TileTilesTileMatrixSetIdZXYGetColormapName = {
  accent: "accent",
  accent_r: "accent_r",
  afmhot: "afmhot",
  afmhot_r: "afmhot_r",
  algae: "algae",
  algae_r: "algae_r",
  amp: "amp",
  amp_r: "amp_r",
  autumn: "autumn",
  autumn_r: "autumn_r",
  balance: "balance",
  balance_r: "balance_r",
  binary: "binary",
  binary_r: "binary_r",
  blues: "blues",
  blues_r: "blues_r",
  bone: "bone",
  bone_r: "bone_r",
  brbg: "brbg",
  brbg_r: "brbg_r",
  brg: "brg",
  brg_r: "brg_r",
  bugn: "bugn",
  bugn_r: "bugn_r",
  bupu: "bupu",
  bupu_r: "bupu_r",
  bwr: "bwr",
  bwr_r: "bwr_r",
  cfastie: "cfastie",
  cividis: "cividis",
  cividis_r: "cividis_r",
  cmrmap: "cmrmap",
  cmrmap_r: "cmrmap_r",
  cool: "cool",
  cool_r: "cool_r",
  coolwarm: "coolwarm",
  coolwarm_r: "coolwarm_r",
  copper: "copper",
  copper_r: "copper_r",
  cubehelix: "cubehelix",
  cubehelix_r: "cubehelix_r",
  curl: "curl",
  curl_r: "curl_r",
  dark2: "dark2",
  dark2_r: "dark2_r",
  deep: "deep",
  deep_r: "deep_r",
  delta: "delta",
  delta_r: "delta_r",
  dense: "dense",
  dense_r: "dense_r",
  diff: "diff",
  diff_r: "diff_r",
  flag: "flag",
  flag_r: "flag_r",
  gist_earth: "gist_earth",
  gist_earth_r: "gist_earth_r",
  gist_gray: "gist_gray",
  gist_gray_r: "gist_gray_r",
  gist_heat: "gist_heat",
  gist_heat_r: "gist_heat_r",
  gist_ncar: "gist_ncar",
  gist_ncar_r: "gist_ncar_r",
  gist_rainbow: "gist_rainbow",
  gist_rainbow_r: "gist_rainbow_r",
  gist_stern: "gist_stern",
  gist_stern_r: "gist_stern_r",
  gist_yarg: "gist_yarg",
  gist_yarg_r: "gist_yarg_r",
  gnbu: "gnbu",
  gnbu_r: "gnbu_r",
  gnuplot: "gnuplot",
  gnuplot2: "gnuplot2",
  gnuplot2_r: "gnuplot2_r",
  gnuplot_r: "gnuplot_r",
  gray: "gray",
  gray_r: "gray_r",
  greens: "greens",
  greens_r: "greens_r",
  greys: "greys",
  greys_r: "greys_r",
  haline: "haline",
  haline_r: "haline_r",
  hot: "hot",
  hot_r: "hot_r",
  hsv: "hsv",
  hsv_r: "hsv_r",
  ice: "ice",
  ice_r: "ice_r",
  inferno: "inferno",
  inferno_r: "inferno_r",
  jet: "jet",
  jet_r: "jet_r",
  magma: "magma",
  magma_r: "magma_r",
  matter: "matter",
  matter_r: "matter_r",
  nipy_spectral: "nipy_spectral",
  nipy_spectral_r: "nipy_spectral_r",
  ocean: "ocean",
  ocean_r: "ocean_r",
  oranges: "oranges",
  oranges_r: "oranges_r",
  orrd: "orrd",
  orrd_r: "orrd_r",
  oxy: "oxy",
  oxy_r: "oxy_r",
  paired: "paired",
  paired_r: "paired_r",
  pastel1: "pastel1",
  pastel1_r: "pastel1_r",
  pastel2: "pastel2",
  pastel2_r: "pastel2_r",
  phase: "phase",
  phase_r: "phase_r",
  pink: "pink",
  pink_r: "pink_r",
  piyg: "piyg",
  piyg_r: "piyg_r",
  plasma: "plasma",
  plasma_r: "plasma_r",
  prgn: "prgn",
  prgn_r: "prgn_r",
  prism: "prism",
  prism_r: "prism_r",
  pubu: "pubu",
  pubu_r: "pubu_r",
  pubugn: "pubugn",
  pubugn_r: "pubugn_r",
  puor: "puor",
  puor_r: "puor_r",
  purd: "purd",
  purd_r: "purd_r",
  purples: "purples",
  purples_r: "purples_r",
  rain: "rain",
  rain_r: "rain_r",
  rainbow: "rainbow",
  rainbow_r: "rainbow_r",
  rdbu: "rdbu",
  rdbu_r: "rdbu_r",
  rdgy: "rdgy",
  rdgy_r: "rdgy_r",
  rdpu: "rdpu",
  rdpu_r: "rdpu_r",
  rdylbu: "rdylbu",
  rdylbu_r: "rdylbu_r",
  rdylgn: "rdylgn",
  rdylgn_r: "rdylgn_r",
  reds: "reds",
  reds_r: "reds_r",
  rplumbo: "rplumbo",
  schwarzwald: "schwarzwald",
  seismic: "seismic",
  seismic_r: "seismic_r",
  set1: "set1",
  set1_r: "set1_r",
  set2: "set2",
  set2_r: "set2_r",
  set3: "set3",
  set3_r: "set3_r",
  solar: "solar",
  solar_r: "solar_r",
  spectral: "spectral",
  spectral_r: "spectral_r",
  speed: "speed",
  speed_r: "speed_r",
  spring: "spring",
  spring_r: "spring_r",
  summer: "summer",
  summer_r: "summer_r",
  tab10: "tab10",
  tab10_r: "tab10_r",
  tab20: "tab20",
  tab20_r: "tab20_r",
  tab20b: "tab20b",
  tab20b_r: "tab20b_r",
  tab20c: "tab20c",
  tab20c_r: "tab20c_r",
  tarn: "tarn",
  tarn_r: "tarn_r",
  tempo: "tempo",
  tempo_r: "tempo_r",
  terrain: "terrain",
  terrain_r: "terrain_r",
  thermal: "thermal",
  thermal_r: "thermal_r",
  topo: "topo",
  topo_r: "topo_r",
  turbid: "turbid",
  turbid_r: "turbid_r",
  turbo: "turbo",
  turbo_r: "turbo_r",
  twilight: "twilight",
  twilight_r: "twilight_r",
  twilight_shifted: "twilight_shifted",
  twilight_shifted_r: "twilight_shifted_r",
  viridis: "viridis",
  viridis_r: "viridis_r",
  winter: "winter",
  winter_r: "winter_r",
  wistia: "wistia",
  wistia_r: "wistia_r",
  ylgn: "ylgn",
  ylgn_r: "ylgn_r",
  ylgnbu: "ylgnbu",
  ylgnbu_r: "ylgnbu_r",
  ylorbr: "ylorbr",
  ylorbr_r: "ylorbr_r",
  ylorrd: "ylorrd",
  ylorrd_r: "ylorrd_r",
} as const;

export type TileTilesTileMatrixSetIdZXYGetAlgorithm =
  (typeof TileTilesTileMatrixSetIdZXYGetAlgorithm)[keyof typeof TileTilesTileMatrixSetIdZXYGetAlgorithm];

export const TileTilesTileMatrixSetIdZXYGetAlgorithm = {
  hillshade: "hillshade",
  slope: "slope",
  contours: "contours",
  normalizedIndex: "normalizedIndex",
  terrarium: "terrarium",
  terrainrgb: "terrainrgb",
  cast: "cast",
  ceil: "ceil",
  floor: "floor",
} as const;

export type TileTilesTileMatrixSetIdZXYGetParams = {
  scale?: number;
  format?: ImageType;
  /**
   * Raster filename.
   */
  raster_filename: string;
  /**
   * Buffer on each side of the given tile. It must be a multiple of `0.5`. Output **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257, 1.0 = 258x258).
   */
  buffer?: number | null;
  /**
   * Padding to apply to each tile edge. Helps reduce resampling artefacts along edges. Defaults to `0`.
   */
  padding?: number | null;
  /**
   * Dataset band indexes
   */
  bidx?: number[] | null;
  /**
   * rio-tiler's band math expression
   */
  expression?: string | null;
  /**
   * Overwrite internal Nodata value
   */
  nodata?: number | number | string | null;
  /**
   * Apply internal Scale/Offset. Defaults to `False`.
   */
  unscale?: boolean | null;
  /**
   * RasterIO resampling algorithm. Defaults to `nearest`.
   */
  resampling?:
    | "nearest"
    | "bilinear"
    | "cubic"
    | "cubic_spline"
    | "lanczos"
    | "average"
    | "mode"
    | "gauss"
    | "rms"
    | null;
  /**
   * WarpKernel resampling algorithm (only used when doing re-projection). Defaults to `nearest`.
   */
  reproject?:
    | "nearest"
    | "bilinear"
    | "cubic"
    | "cubic_spline"
    | "lanczos"
    | "average"
    | "mode"
    | "sum"
    | "rms"
    | null;
  /**
   * Algorithm name
   */
  algorithm?: TileTilesTileMatrixSetIdZXYGetAlgorithm;
  /**
   * Algorithm parameter
   */
  algorithm_params?: string | null;
  /**
   * Colormap name
   */
  colormap_name?: TileTilesTileMatrixSetIdZXYGetColormapName;
  /**
   * JSON encoded custom Colormap
   */
  colormap?: string | null;
  /**
   * comma (',') delimited Min,Max range. Can set multiple time for multiple bands.
   */
  rescale?: string[] | null;
  /**
   * rio-color formula (info: https://github.com/mapbox/rio-color)
   */
  color_formula?: string | null;
  /**
   * Add mask to the output data. Defaults to `True`
   */
  return_mask?: boolean | null;
};

export type TileTilesTileMatrixSetIdZXYFormatGetColormapName =
  (typeof TileTilesTileMatrixSetIdZXYFormatGetColormapName)[keyof typeof TileTilesTileMatrixSetIdZXYFormatGetColormapName];

export const TileTilesTileMatrixSetIdZXYFormatGetColormapName = {
  accent: "accent",
  accent_r: "accent_r",
  afmhot: "afmhot",
  afmhot_r: "afmhot_r",
  algae: "algae",
  algae_r: "algae_r",
  amp: "amp",
  amp_r: "amp_r",
  autumn: "autumn",
  autumn_r: "autumn_r",
  balance: "balance",
  balance_r: "balance_r",
  binary: "binary",
  binary_r: "binary_r",
  blues: "blues",
  blues_r: "blues_r",
  bone: "bone",
  bone_r: "bone_r",
  brbg: "brbg",
  brbg_r: "brbg_r",
  brg: "brg",
  brg_r: "brg_r",
  bugn: "bugn",
  bugn_r: "bugn_r",
  bupu: "bupu",
  bupu_r: "bupu_r",
  bwr: "bwr",
  bwr_r: "bwr_r",
  cfastie: "cfastie",
  cividis: "cividis",
  cividis_r: "cividis_r",
  cmrmap: "cmrmap",
  cmrmap_r: "cmrmap_r",
  cool: "cool",
  cool_r: "cool_r",
  coolwarm: "coolwarm",
  coolwarm_r: "coolwarm_r",
  copper: "copper",
  copper_r: "copper_r",
  cubehelix: "cubehelix",
  cubehelix_r: "cubehelix_r",
  curl: "curl",
  curl_r: "curl_r",
  dark2: "dark2",
  dark2_r: "dark2_r",
  deep: "deep",
  deep_r: "deep_r",
  delta: "delta",
  delta_r: "delta_r",
  dense: "dense",
  dense_r: "dense_r",
  diff: "diff",
  diff_r: "diff_r",
  flag: "flag",
  flag_r: "flag_r",
  gist_earth: "gist_earth",
  gist_earth_r: "gist_earth_r",
  gist_gray: "gist_gray",
  gist_gray_r: "gist_gray_r",
  gist_heat: "gist_heat",
  gist_heat_r: "gist_heat_r",
  gist_ncar: "gist_ncar",
  gist_ncar_r: "gist_ncar_r",
  gist_rainbow: "gist_rainbow",
  gist_rainbow_r: "gist_rainbow_r",
  gist_stern: "gist_stern",
  gist_stern_r: "gist_stern_r",
  gist_yarg: "gist_yarg",
  gist_yarg_r: "gist_yarg_r",
  gnbu: "gnbu",
  gnbu_r: "gnbu_r",
  gnuplot: "gnuplot",
  gnuplot2: "gnuplot2",
  gnuplot2_r: "gnuplot2_r",
  gnuplot_r: "gnuplot_r",
  gray: "gray",
  gray_r: "gray_r",
  greens: "greens",
  greens_r: "greens_r",
  greys: "greys",
  greys_r: "greys_r",
  haline: "haline",
  haline_r: "haline_r",
  hot: "hot",
  hot_r: "hot_r",
  hsv: "hsv",
  hsv_r: "hsv_r",
  ice: "ice",
  ice_r: "ice_r",
  inferno: "inferno",
  inferno_r: "inferno_r",
  jet: "jet",
  jet_r: "jet_r",
  magma: "magma",
  magma_r: "magma_r",
  matter: "matter",
  matter_r: "matter_r",
  nipy_spectral: "nipy_spectral",
  nipy_spectral_r: "nipy_spectral_r",
  ocean: "ocean",
  ocean_r: "ocean_r",
  oranges: "oranges",
  oranges_r: "oranges_r",
  orrd: "orrd",
  orrd_r: "orrd_r",
  oxy: "oxy",
  oxy_r: "oxy_r",
  paired: "paired",
  paired_r: "paired_r",
  pastel1: "pastel1",
  pastel1_r: "pastel1_r",
  pastel2: "pastel2",
  pastel2_r: "pastel2_r",
  phase: "phase",
  phase_r: "phase_r",
  pink: "pink",
  pink_r: "pink_r",
  piyg: "piyg",
  piyg_r: "piyg_r",
  plasma: "plasma",
  plasma_r: "plasma_r",
  prgn: "prgn",
  prgn_r: "prgn_r",
  prism: "prism",
  prism_r: "prism_r",
  pubu: "pubu",
  pubu_r: "pubu_r",
  pubugn: "pubugn",
  pubugn_r: "pubugn_r",
  puor: "puor",
  puor_r: "puor_r",
  purd: "purd",
  purd_r: "purd_r",
  purples: "purples",
  purples_r: "purples_r",
  rain: "rain",
  rain_r: "rain_r",
  rainbow: "rainbow",
  rainbow_r: "rainbow_r",
  rdbu: "rdbu",
  rdbu_r: "rdbu_r",
  rdgy: "rdgy",
  rdgy_r: "rdgy_r",
  rdpu: "rdpu",
  rdpu_r: "rdpu_r",
  rdylbu: "rdylbu",
  rdylbu_r: "rdylbu_r",
  rdylgn: "rdylgn",
  rdylgn_r: "rdylgn_r",
  reds: "reds",
  reds_r: "reds_r",
  rplumbo: "rplumbo",
  schwarzwald: "schwarzwald",
  seismic: "seismic",
  seismic_r: "seismic_r",
  set1: "set1",
  set1_r: "set1_r",
  set2: "set2",
  set2_r: "set2_r",
  set3: "set3",
  set3_r: "set3_r",
  solar: "solar",
  solar_r: "solar_r",
  spectral: "spectral",
  spectral_r: "spectral_r",
  speed: "speed",
  speed_r: "speed_r",
  spring: "spring",
  spring_r: "spring_r",
  summer: "summer",
  summer_r: "summer_r",
  tab10: "tab10",
  tab10_r: "tab10_r",
  tab20: "tab20",
  tab20_r: "tab20_r",
  tab20b: "tab20b",
  tab20b_r: "tab20b_r",
  tab20c: "tab20c",
  tab20c_r: "tab20c_r",
  tarn: "tarn",
  tarn_r: "tarn_r",
  tempo: "tempo",
  tempo_r: "tempo_r",
  terrain: "terrain",
  terrain_r: "terrain_r",
  thermal: "thermal",
  thermal_r: "thermal_r",
  topo: "topo",
  topo_r: "topo_r",
  turbid: "turbid",
  turbid_r: "turbid_r",
  turbo: "turbo",
  turbo_r: "turbo_r",
  twilight: "twilight",
  twilight_r: "twilight_r",
  twilight_shifted: "twilight_shifted",
  twilight_shifted_r: "twilight_shifted_r",
  viridis: "viridis",
  viridis_r: "viridis_r",
  winter: "winter",
  winter_r: "winter_r",
  wistia: "wistia",
  wistia_r: "wistia_r",
  ylgn: "ylgn",
  ylgn_r: "ylgn_r",
  ylgnbu: "ylgnbu",
  ylgnbu_r: "ylgnbu_r",
  ylorbr: "ylorbr",
  ylorbr_r: "ylorbr_r",
  ylorrd: "ylorrd",
  ylorrd_r: "ylorrd_r",
} as const;

export type TileTilesTileMatrixSetIdZXYFormatGetAlgorithm =
  (typeof TileTilesTileMatrixSetIdZXYFormatGetAlgorithm)[keyof typeof TileTilesTileMatrixSetIdZXYFormatGetAlgorithm];

export const TileTilesTileMatrixSetIdZXYFormatGetAlgorithm = {
  hillshade: "hillshade",
  slope: "slope",
  contours: "contours",
  normalizedIndex: "normalizedIndex",
  terrarium: "terrarium",
  terrainrgb: "terrainrgb",
  cast: "cast",
  ceil: "ceil",
  floor: "floor",
} as const;

export type TileTilesTileMatrixSetIdZXYFormatGetParams = {
  scale?: number;
  /**
   * Raster filename.
   */
  raster_filename: string;
  /**
   * Buffer on each side of the given tile. It must be a multiple of `0.5`. Output **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257, 1.0 = 258x258).
   */
  buffer?: number | null;
  /**
   * Padding to apply to each tile edge. Helps reduce resampling artefacts along edges. Defaults to `0`.
   */
  padding?: number | null;
  /**
   * Dataset band indexes
   */
  bidx?: number[] | null;
  /**
   * rio-tiler's band math expression
   */
  expression?: string | null;
  /**
   * Overwrite internal Nodata value
   */
  nodata?: number | number | string | null;
  /**
   * Apply internal Scale/Offset. Defaults to `False`.
   */
  unscale?: boolean | null;
  /**
   * RasterIO resampling algorithm. Defaults to `nearest`.
   */
  resampling?:
    | "nearest"
    | "bilinear"
    | "cubic"
    | "cubic_spline"
    | "lanczos"
    | "average"
    | "mode"
    | "gauss"
    | "rms"
    | null;
  /**
   * WarpKernel resampling algorithm (only used when doing re-projection). Defaults to `nearest`.
   */
  reproject?:
    | "nearest"
    | "bilinear"
    | "cubic"
    | "cubic_spline"
    | "lanczos"
    | "average"
    | "mode"
    | "sum"
    | "rms"
    | null;
  /**
   * Algorithm name
   */
  algorithm?: TileTilesTileMatrixSetIdZXYFormatGetAlgorithm;
  /**
   * Algorithm parameter
   */
  algorithm_params?: string | null;
  /**
   * Colormap name
   */
  colormap_name?: TileTilesTileMatrixSetIdZXYFormatGetColormapName;
  /**
   * JSON encoded custom Colormap
   */
  colormap?: string | null;
  /**
   * comma (',') delimited Min,Max range. Can set multiple time for multiple bands.
   */
  rescale?: string[] | null;
  /**
   * rio-color formula (info: https://github.com/mapbox/rio-color)
   */
  color_formula?: string | null;
  /**
   * Add mask to the output data. Defaults to `True`
   */
  return_mask?: boolean | null;
};

export type TileTilesTileMatrixSetIdZXYScaleXGetColormapName =
  (typeof TileTilesTileMatrixSetIdZXYScaleXGetColormapName)[keyof typeof TileTilesTileMatrixSetIdZXYScaleXGetColormapName];

export const TileTilesTileMatrixSetIdZXYScaleXGetColormapName = {
  accent: "accent",
  accent_r: "accent_r",
  afmhot: "afmhot",
  afmhot_r: "afmhot_r",
  algae: "algae",
  algae_r: "algae_r",
  amp: "amp",
  amp_r: "amp_r",
  autumn: "autumn",
  autumn_r: "autumn_r",
  balance: "balance",
  balance_r: "balance_r",
  binary: "binary",
  binary_r: "binary_r",
  blues: "blues",
  blues_r: "blues_r",
  bone: "bone",
  bone_r: "bone_r",
  brbg: "brbg",
  brbg_r: "brbg_r",
  brg: "brg",
  brg_r: "brg_r",
  bugn: "bugn",
  bugn_r: "bugn_r",
  bupu: "bupu",
  bupu_r: "bupu_r",
  bwr: "bwr",
  bwr_r: "bwr_r",
  cfastie: "cfastie",
  cividis: "cividis",
  cividis_r: "cividis_r",
  cmrmap: "cmrmap",
  cmrmap_r: "cmrmap_r",
  cool: "cool",
  cool_r: "cool_r",
  coolwarm: "coolwarm",
  coolwarm_r: "coolwarm_r",
  copper: "copper",
  copper_r: "copper_r",
  cubehelix: "cubehelix",
  cubehelix_r: "cubehelix_r",
  curl: "curl",
  curl_r: "curl_r",
  dark2: "dark2",
  dark2_r: "dark2_r",
  deep: "deep",
  deep_r: "deep_r",
  delta: "delta",
  delta_r: "delta_r",
  dense: "dense",
  dense_r: "dense_r",
  diff: "diff",
  diff_r: "diff_r",
  flag: "flag",
  flag_r: "flag_r",
  gist_earth: "gist_earth",
  gist_earth_r: "gist_earth_r",
  gist_gray: "gist_gray",
  gist_gray_r: "gist_gray_r",
  gist_heat: "gist_heat",
  gist_heat_r: "gist_heat_r",
  gist_ncar: "gist_ncar",
  gist_ncar_r: "gist_ncar_r",
  gist_rainbow: "gist_rainbow",
  gist_rainbow_r: "gist_rainbow_r",
  gist_stern: "gist_stern",
  gist_stern_r: "gist_stern_r",
  gist_yarg: "gist_yarg",
  gist_yarg_r: "gist_yarg_r",
  gnbu: "gnbu",
  gnbu_r: "gnbu_r",
  gnuplot: "gnuplot",
  gnuplot2: "gnuplot2",
  gnuplot2_r: "gnuplot2_r",
  gnuplot_r: "gnuplot_r",
  gray: "gray",
  gray_r: "gray_r",
  greens: "greens",
  greens_r: "greens_r",
  greys: "greys",
  greys_r: "greys_r",
  haline: "haline",
  haline_r: "haline_r",
  hot: "hot",
  hot_r: "hot_r",
  hsv: "hsv",
  hsv_r: "hsv_r",
  ice: "ice",
  ice_r: "ice_r",
  inferno: "inferno",
  inferno_r: "inferno_r",
  jet: "jet",
  jet_r: "jet_r",
  magma: "magma",
  magma_r: "magma_r",
  matter: "matter",
  matter_r: "matter_r",
  nipy_spectral: "nipy_spectral",
  nipy_spectral_r: "nipy_spectral_r",
  ocean: "ocean",
  ocean_r: "ocean_r",
  oranges: "oranges",
  oranges_r: "oranges_r",
  orrd: "orrd",
  orrd_r: "orrd_r",
  oxy: "oxy",
  oxy_r: "oxy_r",
  paired: "paired",
  paired_r: "paired_r",
  pastel1: "pastel1",
  pastel1_r: "pastel1_r",
  pastel2: "pastel2",
  pastel2_r: "pastel2_r",
  phase: "phase",
  phase_r: "phase_r",
  pink: "pink",
  pink_r: "pink_r",
  piyg: "piyg",
  piyg_r: "piyg_r",
  plasma: "plasma",
  plasma_r: "plasma_r",
  prgn: "prgn",
  prgn_r: "prgn_r",
  prism: "prism",
  prism_r: "prism_r",
  pubu: "pubu",
  pubu_r: "pubu_r",
  pubugn: "pubugn",
  pubugn_r: "pubugn_r",
  puor: "puor",
  puor_r: "puor_r",
  purd: "purd",
  purd_r: "purd_r",
  purples: "purples",
  purples_r: "purples_r",
  rain: "rain",
  rain_r: "rain_r",
  rainbow: "rainbow",
  rainbow_r: "rainbow_r",
  rdbu: "rdbu",
  rdbu_r: "rdbu_r",
  rdgy: "rdgy",
  rdgy_r: "rdgy_r",
  rdpu: "rdpu",
  rdpu_r: "rdpu_r",
  rdylbu: "rdylbu",
  rdylbu_r: "rdylbu_r",
  rdylgn: "rdylgn",
  rdylgn_r: "rdylgn_r",
  reds: "reds",
  reds_r: "reds_r",
  rplumbo: "rplumbo",
  schwarzwald: "schwarzwald",
  seismic: "seismic",
  seismic_r: "seismic_r",
  set1: "set1",
  set1_r: "set1_r",
  set2: "set2",
  set2_r: "set2_r",
  set3: "set3",
  set3_r: "set3_r",
  solar: "solar",
  solar_r: "solar_r",
  spectral: "spectral",
  spectral_r: "spectral_r",
  speed: "speed",
  speed_r: "speed_r",
  spring: "spring",
  spring_r: "spring_r",
  summer: "summer",
  summer_r: "summer_r",
  tab10: "tab10",
  tab10_r: "tab10_r",
  tab20: "tab20",
  tab20_r: "tab20_r",
  tab20b: "tab20b",
  tab20b_r: "tab20b_r",
  tab20c: "tab20c",
  tab20c_r: "tab20c_r",
  tarn: "tarn",
  tarn_r: "tarn_r",
  tempo: "tempo",
  tempo_r: "tempo_r",
  terrain: "terrain",
  terrain_r: "terrain_r",
  thermal: "thermal",
  thermal_r: "thermal_r",
  topo: "topo",
  topo_r: "topo_r",
  turbid: "turbid",
  turbid_r: "turbid_r",
  turbo: "turbo",
  turbo_r: "turbo_r",
  twilight: "twilight",
  twilight_r: "twilight_r",
  twilight_shifted: "twilight_shifted",
  twilight_shifted_r: "twilight_shifted_r",
  viridis: "viridis",
  viridis_r: "viridis_r",
  winter: "winter",
  winter_r: "winter_r",
  wistia: "wistia",
  wistia_r: "wistia_r",
  ylgn: "ylgn",
  ylgn_r: "ylgn_r",
  ylgnbu: "ylgnbu",
  ylgnbu_r: "ylgnbu_r",
  ylorbr: "ylorbr",
  ylorbr_r: "ylorbr_r",
  ylorrd: "ylorrd",
  ylorrd_r: "ylorrd_r",
} as const;

export type TileTilesTileMatrixSetIdZXYScaleXGetAlgorithm =
  (typeof TileTilesTileMatrixSetIdZXYScaleXGetAlgorithm)[keyof typeof TileTilesTileMatrixSetIdZXYScaleXGetAlgorithm];

export const TileTilesTileMatrixSetIdZXYScaleXGetAlgorithm = {
  hillshade: "hillshade",
  slope: "slope",
  contours: "contours",
  normalizedIndex: "normalizedIndex",
  terrarium: "terrarium",
  terrainrgb: "terrainrgb",
  cast: "cast",
  ceil: "ceil",
  floor: "floor",
} as const;

export type TileTilesTileMatrixSetIdZXYScaleXGetParams = {
  format?: ImageType;
  /**
   * Raster filename.
   */
  raster_filename: string;
  /**
   * Buffer on each side of the given tile. It must be a multiple of `0.5`. Output **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257, 1.0 = 258x258).
   */
  buffer?: number | null;
  /**
   * Padding to apply to each tile edge. Helps reduce resampling artefacts along edges. Defaults to `0`.
   */
  padding?: number | null;
  /**
   * Dataset band indexes
   */
  bidx?: number[] | null;
  /**
   * rio-tiler's band math expression
   */
  expression?: string | null;
  /**
   * Overwrite internal Nodata value
   */
  nodata?: number | number | string | null;
  /**
   * Apply internal Scale/Offset. Defaults to `False`.
   */
  unscale?: boolean | null;
  /**
   * RasterIO resampling algorithm. Defaults to `nearest`.
   */
  resampling?:
    | "nearest"
    | "bilinear"
    | "cubic"
    | "cubic_spline"
    | "lanczos"
    | "average"
    | "mode"
    | "gauss"
    | "rms"
    | null;
  /**
   * WarpKernel resampling algorithm (only used when doing re-projection). Defaults to `nearest`.
   */
  reproject?:
    | "nearest"
    | "bilinear"
    | "cubic"
    | "cubic_spline"
    | "lanczos"
    | "average"
    | "mode"
    | "sum"
    | "rms"
    | null;
  /**
   * Algorithm name
   */
  algorithm?: TileTilesTileMatrixSetIdZXYScaleXGetAlgorithm;
  /**
   * Algorithm parameter
   */
  algorithm_params?: string | null;
  /**
   * Colormap name
   */
  colormap_name?: TileTilesTileMatrixSetIdZXYScaleXGetColormapName;
  /**
   * JSON encoded custom Colormap
   */
  colormap?: string | null;
  /**
   * comma (',') delimited Min,Max range. Can set multiple time for multiple bands.
   */
  rescale?: string[] | null;
  /**
   * rio-color formula (info: https://github.com/mapbox/rio-color)
   */
  color_formula?: string | null;
  /**
   * Add mask to the output data. Defaults to `True`
   */
  return_mask?: boolean | null;
};

export type TileTilesTileMatrixSetIdZXYScaleXFormatGetColormapName =
  (typeof TileTilesTileMatrixSetIdZXYScaleXFormatGetColormapName)[keyof typeof TileTilesTileMatrixSetIdZXYScaleXFormatGetColormapName];

export const TileTilesTileMatrixSetIdZXYScaleXFormatGetColormapName = {
  accent: "accent",
  accent_r: "accent_r",
  afmhot: "afmhot",
  afmhot_r: "afmhot_r",
  algae: "algae",
  algae_r: "algae_r",
  amp: "amp",
  amp_r: "amp_r",
  autumn: "autumn",
  autumn_r: "autumn_r",
  balance: "balance",
  balance_r: "balance_r",
  binary: "binary",
  binary_r: "binary_r",
  blues: "blues",
  blues_r: "blues_r",
  bone: "bone",
  bone_r: "bone_r",
  brbg: "brbg",
  brbg_r: "brbg_r",
  brg: "brg",
  brg_r: "brg_r",
  bugn: "bugn",
  bugn_r: "bugn_r",
  bupu: "bupu",
  bupu_r: "bupu_r",
  bwr: "bwr",
  bwr_r: "bwr_r",
  cfastie: "cfastie",
  cividis: "cividis",
  cividis_r: "cividis_r",
  cmrmap: "cmrmap",
  cmrmap_r: "cmrmap_r",
  cool: "cool",
  cool_r: "cool_r",
  coolwarm: "coolwarm",
  coolwarm_r: "coolwarm_r",
  copper: "copper",
  copper_r: "copper_r",
  cubehelix: "cubehelix",
  cubehelix_r: "cubehelix_r",
  curl: "curl",
  curl_r: "curl_r",
  dark2: "dark2",
  dark2_r: "dark2_r",
  deep: "deep",
  deep_r: "deep_r",
  delta: "delta",
  delta_r: "delta_r",
  dense: "dense",
  dense_r: "dense_r",
  diff: "diff",
  diff_r: "diff_r",
  flag: "flag",
  flag_r: "flag_r",
  gist_earth: "gist_earth",
  gist_earth_r: "gist_earth_r",
  gist_gray: "gist_gray",
  gist_gray_r: "gist_gray_r",
  gist_heat: "gist_heat",
  gist_heat_r: "gist_heat_r",
  gist_ncar: "gist_ncar",
  gist_ncar_r: "gist_ncar_r",
  gist_rainbow: "gist_rainbow",
  gist_rainbow_r: "gist_rainbow_r",
  gist_stern: "gist_stern",
  gist_stern_r: "gist_stern_r",
  gist_yarg: "gist_yarg",
  gist_yarg_r: "gist_yarg_r",
  gnbu: "gnbu",
  gnbu_r: "gnbu_r",
  gnuplot: "gnuplot",
  gnuplot2: "gnuplot2",
  gnuplot2_r: "gnuplot2_r",
  gnuplot_r: "gnuplot_r",
  gray: "gray",
  gray_r: "gray_r",
  greens: "greens",
  greens_r: "greens_r",
  greys: "greys",
  greys_r: "greys_r",
  haline: "haline",
  haline_r: "haline_r",
  hot: "hot",
  hot_r: "hot_r",
  hsv: "hsv",
  hsv_r: "hsv_r",
  ice: "ice",
  ice_r: "ice_r",
  inferno: "inferno",
  inferno_r: "inferno_r",
  jet: "jet",
  jet_r: "jet_r",
  magma: "magma",
  magma_r: "magma_r",
  matter: "matter",
  matter_r: "matter_r",
  nipy_spectral: "nipy_spectral",
  nipy_spectral_r: "nipy_spectral_r",
  ocean: "ocean",
  ocean_r: "ocean_r",
  oranges: "oranges",
  oranges_r: "oranges_r",
  orrd: "orrd",
  orrd_r: "orrd_r",
  oxy: "oxy",
  oxy_r: "oxy_r",
  paired: "paired",
  paired_r: "paired_r",
  pastel1: "pastel1",
  pastel1_r: "pastel1_r",
  pastel2: "pastel2",
  pastel2_r: "pastel2_r",
  phase: "phase",
  phase_r: "phase_r",
  pink: "pink",
  pink_r: "pink_r",
  piyg: "piyg",
  piyg_r: "piyg_r",
  plasma: "plasma",
  plasma_r: "plasma_r",
  prgn: "prgn",
  prgn_r: "prgn_r",
  prism: "prism",
  prism_r: "prism_r",
  pubu: "pubu",
  pubu_r: "pubu_r",
  pubugn: "pubugn",
  pubugn_r: "pubugn_r",
  puor: "puor",
  puor_r: "puor_r",
  purd: "purd",
  purd_r: "purd_r",
  purples: "purples",
  purples_r: "purples_r",
  rain: "rain",
  rain_r: "rain_r",
  rainbow: "rainbow",
  rainbow_r: "rainbow_r",
  rdbu: "rdbu",
  rdbu_r: "rdbu_r",
  rdgy: "rdgy",
  rdgy_r: "rdgy_r",
  rdpu: "rdpu",
  rdpu_r: "rdpu_r",
  rdylbu: "rdylbu",
  rdylbu_r: "rdylbu_r",
  rdylgn: "rdylgn",
  rdylgn_r: "rdylgn_r",
  reds: "reds",
  reds_r: "reds_r",
  rplumbo: "rplumbo",
  schwarzwald: "schwarzwald",
  seismic: "seismic",
  seismic_r: "seismic_r",
  set1: "set1",
  set1_r: "set1_r",
  set2: "set2",
  set2_r: "set2_r",
  set3: "set3",
  set3_r: "set3_r",
  solar: "solar",
  solar_r: "solar_r",
  spectral: "spectral",
  spectral_r: "spectral_r",
  speed: "speed",
  speed_r: "speed_r",
  spring: "spring",
  spring_r: "spring_r",
  summer: "summer",
  summer_r: "summer_r",
  tab10: "tab10",
  tab10_r: "tab10_r",
  tab20: "tab20",
  tab20_r: "tab20_r",
  tab20b: "tab20b",
  tab20b_r: "tab20b_r",
  tab20c: "tab20c",
  tab20c_r: "tab20c_r",
  tarn: "tarn",
  tarn_r: "tarn_r",
  tempo: "tempo",
  tempo_r: "tempo_r",
  terrain: "terrain",
  terrain_r: "terrain_r",
  thermal: "thermal",
  thermal_r: "thermal_r",
  topo: "topo",
  topo_r: "topo_r",
  turbid: "turbid",
  turbid_r: "turbid_r",
  turbo: "turbo",
  turbo_r: "turbo_r",
  twilight: "twilight",
  twilight_r: "twilight_r",
  twilight_shifted: "twilight_shifted",
  twilight_shifted_r: "twilight_shifted_r",
  viridis: "viridis",
  viridis_r: "viridis_r",
  winter: "winter",
  winter_r: "winter_r",
  wistia: "wistia",
  wistia_r: "wistia_r",
  ylgn: "ylgn",
  ylgn_r: "ylgn_r",
  ylgnbu: "ylgnbu",
  ylgnbu_r: "ylgnbu_r",
  ylorbr: "ylorbr",
  ylorbr_r: "ylorbr_r",
  ylorrd: "ylorrd",
  ylorrd_r: "ylorrd_r",
} as const;

export type TileTilesTileMatrixSetIdZXYScaleXFormatGetAlgorithm =
  (typeof TileTilesTileMatrixSetIdZXYScaleXFormatGetAlgorithm)[keyof typeof TileTilesTileMatrixSetIdZXYScaleXFormatGetAlgorithm];

export const TileTilesTileMatrixSetIdZXYScaleXFormatGetAlgorithm = {
  hillshade: "hillshade",
  slope: "slope",
  contours: "contours",
  normalizedIndex: "normalizedIndex",
  terrarium: "terrarium",
  terrainrgb: "terrainrgb",
  cast: "cast",
  ceil: "ceil",
  floor: "floor",
} as const;

export type TileTilesTileMatrixSetIdZXYScaleXFormatGetParams = {
  /**
   * Raster filename.
   */
  raster_filename: string;
  /**
   * Buffer on each side of the given tile. It must be a multiple of `0.5`. Output **tilesize** will be expanded to `tilesize + 2 * buffer` (e.g 0.5 = 257x257, 1.0 = 258x258).
   */
  buffer?: number | null;
  /**
   * Padding to apply to each tile edge. Helps reduce resampling artefacts along edges. Defaults to `0`.
   */
  padding?: number | null;
  /**
   * Dataset band indexes
   */
  bidx?: number[] | null;
  /**
   * rio-tiler's band math expression
   */
  expression?: string | null;
  /**
   * Overwrite internal Nodata value
   */
  nodata?: number | number | string | null;
  /**
   * Apply internal Scale/Offset. Defaults to `False`.
   */
  unscale?: boolean | null;
  /**
   * RasterIO resampling algorithm. Defaults to `nearest`.
   */
  resampling?:
    | "nearest"
    | "bilinear"
    | "cubic"
    | "cubic_spline"
    | "lanczos"
    | "average"
    | "mode"
    | "gauss"
    | "rms"
    | null;
  /**
   * WarpKernel resampling algorithm (only used when doing re-projection). Defaults to `nearest`.
   */
  reproject?:
    | "nearest"
    | "bilinear"
    | "cubic"
    | "cubic_spline"
    | "lanczos"
    | "average"
    | "mode"
    | "sum"
    | "rms"
    | null;
  /**
   * Algorithm name
   */
  algorithm?: TileTilesTileMatrixSetIdZXYScaleXFormatGetAlgorithm;
  /**
   * Algorithm parameter
   */
  algorithm_params?: string | null;
  /**
   * Colormap name
   */
  colormap_name?: TileTilesTileMatrixSetIdZXYScaleXFormatGetColormapName;
  /**
   * JSON encoded custom Colormap
   */
  colormap?: string | null;
  /**
   * comma (',') delimited Min,Max range. Can set multiple time for multiple bands.
   */
  rescale?: string[] | null;
  /**
   * rio-color formula (info: https://github.com/mapbox/rio-color)
   */
  color_formula?: string | null;
  /**
   * Add mask to the output data. Defaults to `True`
   */
  return_mask?: boolean | null;
};

/**
 * GeoJSON Feature or FeatureCollection.
 */
export type ExactZonalStatsExactZonalStatsPostBody = FeatureCollection | Feature;

export type ExactZonalStatsExactZonalStatsPostParams = {
  /**
   * Statistics to compute. See `StatsProperties` for more details.
   */
  statistics?: StatsOps[];
  /**
   * Raster filename.
   */
  raster_filename: string;
};

export type PointPointLonLatGetParams = {
  /**
   * Raster filename.
   */
  raster_filename: string;
  /**
   * Coordinate Reference System of the input coords. Default to `epsg:4326`.
   */
  coord_crs?: string | null;
  /**
   * Dataset band indexes
   */
  bidx?: number[] | null;
  /**
   * rio-tiler's band math expression
   */
  expression?: string | null;
  /**
   * Overwrite internal Nodata value
   */
  nodata?: number | number | string | null;
  /**
   * Apply internal Scale/Offset. Defaults to `False`.
   */
  unscale?: boolean | null;
  /**
   * RasterIO resampling algorithm. Defaults to `nearest`.
   */
  resampling?:
    | "nearest"
    | "bilinear"
    | "cubic"
    | "cubic_spline"
    | "lanczos"
    | "average"
    | "mode"
    | "gauss"
    | "rms"
    | null;
  /**
   * WarpKernel resampling algorithm (only used when doing re-projection). Defaults to `nearest`.
   */
  reproject?:
    | "nearest"
    | "bilinear"
    | "cubic"
    | "cubic_spline"
    | "lanczos"
    | "average"
    | "mode"
    | "sum"
    | "rms"
    | null;
};

export type ValidationErrorLocItem = string | number;

export interface ValidationError {
  loc: ValidationErrorLocItem[];
  msg: string;
  type: string;
}

export type TileJSONTemplate = string | null;

export type TileJSONScheme = (typeof TileJSONScheme)[keyof typeof TileJSONScheme];

export const TileJSONScheme = {
  xyz: "xyz",
  tms: "tms",
} as const;

export type TileJSONName = string | null;

export type TileJSONLegend = string | null;

export type TileJSONGrids = string[] | null;

export type TileJSONDescription = string | null;

export type TileJSONData = string[] | null;

export type TileJSONCenter = [number, number, number] | null;

export type TileJSONAttribution = string | null;

/**
 * TileJSON model.

Based on https://github.com/mapbox/tilejson-spec/tree/master/2.2.0
 */
export interface TileJSON {
  attribution?: TileJSONAttribution;
  bounds?: number[];
  center?: TileJSONCenter;
  data?: TileJSONData;
  description?: TileJSONDescription;
  grids?: TileJSONGrids;
  legend?: TileJSONLegend;
  /**
   * @minimum 0
   * @maximum 30
   */
  maxzoom?: number;
  /**
   * @minimum 0
   * @maximum 30
   */
  minzoom?: number;
  name?: TileJSONName;
  scheme?: TileJSONScheme;
  template?: TileJSONTemplate;
  tilejson?: string;
  tiles: string[];
  version?: string;
}

export interface TableResultColumn {
  /** Column name */
  column: string;
  /** Check dataset metadata for type info */
  values: unknown[];
}

export interface TableResults {
  cells: string[];
  table: TableResultColumn[];
}

export type StatsPropertiesWeightsAnyOfItem = number | number;

/**
 * Array of weight values for each cell that intersects the polygon.
 */
export type StatsPropertiesWeights = StatsPropertiesWeightsAnyOfItem[] | null;

/**
 * Weighted version of variance.
 */
export type StatsPropertiesWeightedVariance = number | null;

/**
 * Sum of raster cells covered by the polygon, with each raster value weighted by its coverage fraction and weighting raster value.
 */
export type StatsPropertiesWeightedSum = number | null;

/**
 * Weighted version of stdev.
 */
export type StatsPropertiesWeightedStdev = number | null;

/**
 * Mean value of cells that intersect the polygon, weighted by the product over the coverage fraction and the weighting raster.
 */
export type StatsPropertiesWeightedMean = number | null;

/**
 * Fraction of covered cells that are occupied by each distinct raster value, weighted by the value of a second weighting raster.
 */
export type StatsPropertiesWeightedFrac = number[] | null;

/**
 * The number of distinct raster values in cells wholly or partially covered by the polygon.
 */
export type StatsPropertiesVariety = number | null;

/**
 * Population variance of cell values that intersect the polygon, taking into account coverage fraction.
 */
export type StatsPropertiesVariance = number | null;

export type StatsPropertiesUniqueAnyOfItem = number | number;

/**
 * Array of unique raster values for cells that intersect the polygon.
 */
export type StatsPropertiesUnique = StatsPropertiesUniqueAnyOfItem[] | null;

/**
 * Sum of values of raster cells that intersect the polygon, with each raster value weighted by its coverage fraction.
 */
export type StatsPropertiesSum = number | null;

/**
 * Population standard deviation of cell values that intersect the polygon, taking into account coverage fraction.
 */
export type StatsPropertiesStdev = number | null;

/**
 * The raster value occupying the least number of cells, taking into account cell coverage fractions but not weighting raster values.
 */
export type StatsPropertiesMinority = number | number | null;

/**
 * Cell center y-coordinate for the cell containing the minimum value intersected by the polygon. The center of this cell may or may not be inside the polygon.
 */
export type StatsPropertiesMinCenterY = number | null;

/**
 * Cell center x-coordinate for the cell containing the minimum value intersected by the polygon. The center of this cell may or may not be inside the polygon.
 */
export type StatsPropertiesMinCenterX = number | null;

/**
 * Minimum value of cells that intersect the polygon, not taking coverage fractions or weighting raster values into account.
 */
export type StatsPropertiesMin = number | number | null;

/**
 * Median value of cells that intersect the polygon, weighted by the percent of each cell that is covered.
 */
export type StatsPropertiesMedian = number | number | null;

/**
 * Mean value of cells that intersect the polygon, weighted by the percent of each cell that is covered.
 */
export type StatsPropertiesMean = number | null;

/**
 * Cell center y-coordinate for the cell containing the maximum value intersected by the polygon. The center of this cell may or may not be inside the polygon.
 */
export type StatsPropertiesMaxCenterY = number | null;

/**
 * Cell center x-coordinate for the cell containing the maximum value intersected by the polygon. The center of this cell may or may not be inside the polygon.
 */
export type StatsPropertiesMaxCenterX = number | null;

/**
 * Maximum value of cells that intersect the polygon, not taking coverage fractions or weighting raster values into account.
 */
export type StatsPropertiesMax = number | number | null;

/**
 * The raster value occupying the greatest number of cells, taking into account cell coverage fractions but not weighting raster values.
 */
export type StatsPropertiesMajority = number | number | null;

/**
 * Fraction of covered cells that are occupied by each distinct raster value.
 */
export type StatsPropertiesFrac = number[] | null;

/**
 * Array with coverage fraction of each cell that intersects the polygon.
 */
export type StatsPropertiesCoverage = number[] | null;

/**
 * Sum of all cell coverage fractions.
 */
export type StatsPropertiesCount = number | null;

/**
 * Population coefficient of variation of cell values that intersect the polygon, taking into account coverage fraction.
 */
export type StatsPropertiesCoefficientOfVariation = number | null;

/**
 * Array with cell center y-coordinate for each cell that intersects the polygon. Each cell center may or may not be inside the polygon.
 */
export type StatsPropertiesCenterY = number[] | null;

/**
 * Array with cell center x-coordinate for each cell that intersects the polygon. Each cell center may or may not be inside the polygon.
 */
export type StatsPropertiesCenterX = number[] | null;

/**
 * Array with 0-based index of each cell that intersects the polygon, increasing left-to-right.
 */
export type StatsPropertiesCellId = number[] | null;

/**
 * Model for `exact_extract` statistics results.

Deliberately avoids the `values` field since it is a
 list of all raster values for each cell that intersects the polygon.
 It is not included in the model because it can be very large and there are better ways to get this information
 in Titiler.
 */
export interface StatsProperties {
  /** Array with 0-based index of each cell that intersects the polygon, increasing left-to-right. */
  cell_id?: StatsPropertiesCellId;
  /** Array with cell center x-coordinate for each cell that intersects the polygon. Each cell center may or may not be inside the polygon. */
  center_x?: StatsPropertiesCenterX;
  /** Array with cell center y-coordinate for each cell that intersects the polygon. Each cell center may or may not be inside the polygon. */
  center_y?: StatsPropertiesCenterY;
  /** Population coefficient of variation of cell values that intersect the polygon, taking into account coverage fraction. */
  coefficient_of_variation?: StatsPropertiesCoefficientOfVariation;
  /** Sum of all cell coverage fractions. */
  count?: StatsPropertiesCount;
  /** Array with coverage fraction of each cell that intersects the polygon. */
  coverage?: StatsPropertiesCoverage;
  /** Fraction of covered cells that are occupied by each distinct raster value. */
  frac?: StatsPropertiesFrac;
  /** The raster value occupying the greatest number of cells, taking into account cell coverage fractions but not weighting raster values. */
  majority?: StatsPropertiesMajority;
  /** Maximum value of cells that intersect the polygon, not taking coverage fractions or weighting raster values into account. */
  max?: StatsPropertiesMax;
  /** Cell center x-coordinate for the cell containing the maximum value intersected by the polygon. The center of this cell may or may not be inside the polygon. */
  max_center_x?: StatsPropertiesMaxCenterX;
  /** Cell center y-coordinate for the cell containing the maximum value intersected by the polygon. The center of this cell may or may not be inside the polygon. */
  max_center_y?: StatsPropertiesMaxCenterY;
  /** Mean value of cells that intersect the polygon, weighted by the percent of each cell that is covered. */
  mean?: StatsPropertiesMean;
  /** Median value of cells that intersect the polygon, weighted by the percent of each cell that is covered. */
  median?: StatsPropertiesMedian;
  /** Minimum value of cells that intersect the polygon, not taking coverage fractions or weighting raster values into account. */
  min?: StatsPropertiesMin;
  /** Cell center x-coordinate for the cell containing the minimum value intersected by the polygon. The center of this cell may or may not be inside the polygon. */
  min_center_x?: StatsPropertiesMinCenterX;
  /** Cell center y-coordinate for the cell containing the minimum value intersected by the polygon. The center of this cell may or may not be inside the polygon. */
  min_center_y?: StatsPropertiesMinCenterY;
  /** The raster value occupying the least number of cells, taking into account cell coverage fractions but not weighting raster values. */
  minority?: StatsPropertiesMinority;
  /** Population standard deviation of cell values that intersect the polygon, taking into account coverage fraction. */
  stdev?: StatsPropertiesStdev;
  /** Sum of values of raster cells that intersect the polygon, with each raster value weighted by its coverage fraction. */
  sum?: StatsPropertiesSum;
  /** Array of unique raster values for cells that intersect the polygon. */
  unique?: StatsPropertiesUnique;
  /** Population variance of cell values that intersect the polygon, taking into account coverage fraction. */
  variance?: StatsPropertiesVariance;
  /** The number of distinct raster values in cells wholly or partially covered by the polygon. */
  variety?: StatsPropertiesVariety;
  /** Fraction of covered cells that are occupied by each distinct raster value, weighted by the value of a second weighting raster. */
  weighted_frac?: StatsPropertiesWeightedFrac;
  /** Mean value of cells that intersect the polygon, weighted by the product over the coverage fraction and the weighting raster. */
  weighted_mean?: StatsPropertiesWeightedMean;
  /** Weighted version of stdev. */
  weighted_stdev?: StatsPropertiesWeightedStdev;
  /** Sum of raster cells covered by the polygon, with each raster value weighted by its coverage fraction and weighting raster value. */
  weighted_sum?: StatsPropertiesWeightedSum;
  /** Weighted version of variance. */
  weighted_variance?: StatsPropertiesWeightedVariance;
  /** Array of weight values for each cell that intersects the polygon. */
  weights?: StatsPropertiesWeights;
}

/**
 * Statistic operations available in `exact_extract`. See `StatsProperties` for more details.
 */
export type StatsOps = (typeof StatsOps)[keyof typeof StatsOps];

export const StatsOps = {
  cell_id: "cell_id",
  center_x: "center_x",
  center_y: "center_y",
  coefficient_of_variation: "coefficient_of_variation",
  count: "count",
  coverage: "coverage",
  frac: "frac",
  majority: "majority",
  max: "max",
  max_center_x: "max_center_x",
  max_center_y: "max_center_y",
  mean: "mean",
  median: "median",
  min: "min",
  min_center_x: "min_center_x",
  min_center_y: "min_center_y",
  minority: "minority",
  stdev: "stdev",
  sum: "sum",
  unique: "unique",
  variance: "variance",
  variety: "variety",
  weighted_frac: "weighted_frac",
  weighted_mean: "weighted_mean",
  weighted_stdev: "weighted_stdev",
  weighted_sum: "weighted_sum",
  weighted_variance: "weighted_variance",
  weights: "weights",
} as const;

/**
 * Exactextract result model for one feature.
 */
export interface StatsFeature {
  properties: StatsProperties;
  type: string;
}

/**
 * Exactextract result model for multiple features.
 */
export interface StatsFeatures {
  features: StatsFeature[];
}

/**
 * @minItems 3
 * @maxItems 3
 */
export type Position3D = [number, number, number];

/**
 * @minItems 2
 * @maxItems 2
 */
export type Position2D = [number, number];

export type PolygonCoordinatesItemItem = Position2D | Position3D;

export type PolygonBbox =
  | [number, number, number, number]
  | [number, number, number, number, number, number]
  | null;

/**
 * Polygon Model
 */
export interface Polygon {
  bbox?: PolygonBbox;
  coordinates: PolygonCoordinatesItemItem[][];
  type: string;
}

export type PointOutputValuesItem = number | null;

/**
 * Point model.

response model for `/point` endpoints
 */
export interface PointOutput {
  band_names: string[];
  coordinates: number[];
  values: PointOutputValuesItem[];
}

export type PointInputCoordinates = Position2D | Position3D;

export type PointInputBbox =
  | [number, number, number, number]
  | [number, number, number, number, number, number]
  | null;

/**
 * Point Model
 */
export interface PointInput {
  bbox?: PointInputBbox;
  coordinates: PointInputCoordinates;
  type: string;
}

export type NumericalOperators = (typeof NumericalOperators)[keyof typeof NumericalOperators];

export const NumericalOperators = {
  eq: "eq",
  gt: "gt",
  lt: "lt",
  gte: "gte",
  lte: "lte",
  not_eq: "not_eq",
} as const;

export type NumericalLegendLegendType = string | string;

/**
 * suggestion of color map to use
 */
export type NumericalLegendColormapName = string | null;

export interface NumericalLegend {
  /** suggestion of color map to use */
  colormap_name?: NumericalLegendColormapName;
  legend_type: NumericalLegendLegendType;
  stats: LevelStats[];
}

export interface NumericalFilter {
  /** Name of the column to which the filter will apply. */
  column_name: string;
  filter_type: string;
  /** Operation to use in compare. */
  operation: NumericalOperators;
  /** Value to compare with. */
  value: number;
}

export type MultiPolygonCoordinatesItemItemItem = Position2D | Position3D;

export type MultiPolygonBbox =
  | [number, number, number, number]
  | [number, number, number, number, number, number]
  | null;

/**
 * MultiPolygon Model
 */
export interface MultiPolygon {
  bbox?: MultiPolygonBbox;
  coordinates: MultiPolygonCoordinatesItemItemItem[][][];
  type: string;
}

export type MultiPointCoordinatesItem = Position2D | Position3D;

export type MultiPointBbox =
  | [number, number, number, number]
  | [number, number, number, number, number, number]
  | null;

/**
 * MultiPoint Model
 */
export interface MultiPoint {
  bbox?: MultiPointBbox;
  coordinates: MultiPointCoordinatesItem[];
  type: string;
}

export type MultiLineStringCoordinatesItemItem = Position2D | Position3D;

export type MultiLineStringBbox =
  | [number, number, number, number]
  | [number, number, number, number, number, number]
  | null;

/**
 * MultiLineString Model
 */
export interface MultiLineString {
  bbox?: MultiLineStringBbox;
  coordinates: MultiLineStringCoordinatesItemItem[][];
  type: string;
}

export interface MultiDatasetMeta {
  /** Variables represented in this dataset. */
  datasets: DatasetMeta[];
  /** H3 related information. */
  h3_grid_info: H3GridInfo[];
}

export type LineStringCoordinatesItem = Position2D | Position3D;

export type LineStringBbox =
  | [number, number, number, number]
  | [number, number, number, number, number, number]
  | null;

/**
 * LineString Model
 */
export interface LineString {
  bbox?: LineStringBbox;
  /** @minItems 2 */
  coordinates: LineStringCoordinatesItem[];
  type: string;
}

/**
 * null value represents -infinity
 */
export type LevelStatsMin = number | number | null;

/**
 * null value represents infinity
 */
export type LevelStatsMax = number | number | null;

export interface LevelStats {
  /**
   * Stats for this level. AKA Overview or zoom level in other applications
   * @minimum 0
   * @maximum 15
   */
  level: number;
  /** null value represents infinity */
  max: LevelStatsMax;
  /** null value represents -infinity */
  min: LevelStatsMin;
}

/**
 * Available Output image type.
 */
export type ImageType = (typeof ImageType)[keyof typeof ImageType];

export const ImageType = {
  png: "png",
  npy: "npy",
  tif: "tif",
  jpeg: "jpeg",
  jpg: "jpg",
  jp2: "jp2",
  webp: "webp",
  pngraw: "pngraw",
} as const;

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export interface H3GridInfo {
  h3_cells_count: number;
  /**
   * @minimum 0
   * @maximum 15
   */
  h3_cells_resolution: number;
  /**
   * @minimum 0
   * @maximum 15
   */
  level: number;
}

export type GeometryCollectionGeometriesItem =
  | PointInput
  | MultiPoint
  | LineString
  | MultiLineString
  | Polygon
  | MultiPolygon
  | GeometryCollection;

export type GeometryCollectionBbox =
  | [number, number, number, number]
  | [number, number, number, number, number, number]
  | null;

/**
 * GeometryCollection Model
 */
export interface GeometryCollection {
  bbox?: GeometryCollectionBbox;
  geometries: GeometryCollectionGeometriesItem[];
  type: string;
}

export type FeatureCollectionBbox =
  | [number, number, number, number]
  | [number, number, number, number, number, number]
  | null;

/**
 * FeatureCollection Model
 */
export interface FeatureCollection {
  bbox?: FeatureCollectionBbox;
  features: Feature[];
  type: string;
}

export type FeaturePropertiesAnyOf = { [key: string]: unknown };

export type FeatureProperties = FeaturePropertiesAnyOf | BaseModel | null;

export type FeatureId = number | string | null;

/**
 * Feature Model
 */
export interface Feature {
  bbox?: FeatureBbox;
  geometry: FeatureGeometry;
  id?: FeatureId;
  properties: FeatureProperties;
  type: string;
}

export type FeatureGeometryAnyOf =
  | PointInput
  | MultiPoint
  | LineString
  | MultiLineString
  | Polygon
  | MultiPolygon
  | GeometryCollection;

export type FeatureGeometry = FeatureGeometryAnyOf | null;

export type FeatureBbox =
  | [number, number, number, number]
  | [number, number, number, number, number, number]
  | null;

export interface DescritionResponse {
  description: string;
}

/**
 * Unit of the measurement
 */
export type DatasetMetaUnit = string | null;

/**
 * Nodata value used in grid
 */
export type DatasetMetaNodata = string | null;

export type DatasetMetaLegend = CategoricalLegend | NumericalLegend;

export interface DatasetMeta {
  /** Human readable indicator description. */
  description: string;
  /** Human readable name. */
  label: string;
  legend: DatasetMetaLegend;
  /** Nodata value used in grid */
  nodata?: DatasetMetaNodata;
  /** Unit of the measurement */
  unit: DatasetMetaUnit;
  /** Column dtype. */
  var_dtype: string;
  /** Column name. */
  var_name: string;
}

export type ContextLanguage = (typeof ContextLanguage)[keyof typeof ContextLanguage];

export const ContextLanguage = {
  en: "en",
  es: "es",
  pt: "pt",
} as const;

export type ContextDescriptionType =
  (typeof ContextDescriptionType)[keyof typeof ContextDescriptionType];

export const ContextDescriptionType = {
  Short: "Short",
  Normal: "Normal",
  Long: "Long",
} as const;

export type ContextData = { [key: string]: unknown };

export interface Context {
  data: ContextData;
  description_type?: ContextDescriptionType;
  language?: ContextLanguage;
}

export type CategoricalOperators = (typeof CategoricalOperators)[keyof typeof CategoricalOperators];

export const CategoricalOperators = {
  in: "in",
  not_in: "not_in",
} as const;

export type CategoricalLegendEntryValue = number;

export interface CategoricalLegendEntry {
  color: string;
  /** human readable label */
  label: string;
  value: CategoricalLegendEntryValue;
}

export interface CategoricalLegend {
  entries: CategoricalLegendEntry[];
  legend_type: string;
}

export interface CategoricalFilter {
  /** Name of the column to which the filter will apply. */
  column_name: string;
  filter_type: string;
  operation: CategoricalOperators;
  /** Value to compare with. */
  value: number[];
}

export type BodyReadTableGridTablePostGeojson = Feature | null;

export type BodyReadTableGridTablePostFiltersItem = CategoricalFilter | NumericalFilter;

export interface BodyReadTableGridTablePost {
  filters: BodyReadTableGridTablePostFiltersItem[];
  geojson?: BodyReadTableGridTablePostGeojson;
}

export interface BaseModel {
  [key: string]: unknown;
}
