/**
 * Generated by orval v8.2.0 üç∫
 * Do not edit manually.
 * Amazonia360 API
 * OpenAPI spec version: 0.1.0
 */
export interface BaseModel {
  [key: string]: unknown;
}

/**
 * @minItems 2
 * @maxItems 2
 */
export type Position2D = [number, number];

/**
 * @minItems 3
 * @maxItems 3
 */
export type Position3D = [number, number, number];

/**
 * Point Model
 */
export interface Point {
  bbox?: [number, number, number, number] | [number, number, number, number, number, number] | null;
  type: "Point";
  coordinates: Position2D | Position3D;
}

/**
 * MultiPoint Model
 */
export interface MultiPoint {
  bbox?: [number, number, number, number] | [number, number, number, number, number, number] | null;
  type: "MultiPoint";
  coordinates: (Position2D | Position3D)[];
}

/**
 * LineString Model
 */
export interface LineString {
  bbox?: [number, number, number, number] | [number, number, number, number, number, number] | null;
  type: "LineString";
  /** @minItems 2 */
  coordinates: (Position2D | Position3D)[];
}

/**
 * MultiLineString Model
 */
export interface MultiLineString {
  bbox?: [number, number, number, number] | [number, number, number, number, number, number] | null;
  type: "MultiLineString";
  coordinates: (Position2D | Position3D)[][];
}

/**
 * Polygon Model
 */
export interface Polygon {
  bbox?: [number, number, number, number] | [number, number, number, number, number, number] | null;
  type: "Polygon";
  coordinates: (Position2D | Position3D)[][];
}

/**
 * MultiPolygon Model
 */
export interface MultiPolygon {
  bbox?: [number, number, number, number] | [number, number, number, number, number, number] | null;
  type: "MultiPolygon";
  coordinates: (Position2D | Position3D)[][][];
}

/**
 * GeometryCollection Model
 */
export interface GeometryCollection {
  bbox?: [number, number, number, number] | [number, number, number, number, number, number] | null;
  type: "GeometryCollection";
  geometries: (
    | Point
    | MultiPoint
    | LineString
    | MultiLineString
    | Polygon
    | MultiPolygon
    | GeometryCollection
  )[];
}

export type FeatureProperties = { [key: string]: unknown } | BaseModel | null;

/**
 * Feature Model
 */
export interface Feature {
  bbox?: [number, number, number, number] | [number, number, number, number, number, number] | null;
  type: "Feature";
  geometry:
    | Point
    | MultiPoint
    | LineString
    | MultiLineString
    | Polygon
    | MultiPolygon
    | GeometryCollection
    | null;
  properties: FeatureProperties;
  id?: number | string | null;
}

export type CategoricalOperators = (typeof CategoricalOperators)[keyof typeof CategoricalOperators];

export const CategoricalOperators = {
  in: "in",
  not_in: "not_in",
} as const;

export interface CategoricalFilter {
  filter_type: "categorical";
  /** Name of the column to which the filter will apply. */
  column_name: string;
  operation: CategoricalOperators;
  /** Value to compare with. */
  value: number[];
}

export type NumericalOperators = (typeof NumericalOperators)[keyof typeof NumericalOperators];

export const NumericalOperators = {
  eq: "eq",
  gt: "gt",
  lt: "lt",
  gte: "gte",
  lte: "lte",
  not_eq: "not_eq",
} as const;

export interface NumericalFilter {
  filter_type: "numerical";
  /** Name of the column to which the filter will apply. */
  column_name: string;
  /** Operation to use in compare. */
  operation: NumericalOperators;
  /** Value to compare with. */
  value: number;
}

export interface BodyReadTableGridTablePost {
  geojson?: Feature | null;
  filters: (CategoricalFilter | NumericalFilter)[];
}

export interface CategoricalLegendEntry {
  value: number | string;
  color: string;
  /** human readable label */
  label: string;
}

export interface CategoricalLegend {
  legend_type: "categorical";
  entries: CategoricalLegendEntry[];
}

export type ContextData = { [key: string]: unknown };

export type ContextLanguage = (typeof ContextLanguage)[keyof typeof ContextLanguage];

export const ContextLanguage = {
  en: "en",
  es: "es",
  pt: "pt",
} as const;

export type ContextDescriptionType =
  (typeof ContextDescriptionType)[keyof typeof ContextDescriptionType];

export const ContextDescriptionType = {
  Short: "Short",
  Normal: "Normal",
  Long: "Long",
} as const;

export interface Context {
  data: ContextData;
  language?: ContextLanguage;
  description_type?: ContextDescriptionType;
}

export interface LevelStats {
  /**
   * Stats for this level. AKA Overview or zoom level in other applications
   * @minimum 0
   * @maximum 15
   */
  level: number;
  /** null value represents -infinity */
  min: number | null;
  /** null value represents infinity */
  max: number | null;
}

export interface NumericalLegend {
  legend_type: "discrete" | "continuous";
  /** suggestion of color map to use */
  colormap_name?: string | null;
  stats: LevelStats[];
}

export interface DatasetMeta {
  /** Column name. */
  var_name: string;
  /** Column dtype. */
  var_dtype: string;
  /** Human readable name. */
  label: string;
  /** Nodata value used in grid */
  nodata?: string | null;
  /** Human readable indicator description. */
  description: string;
  /** Unit of the measurement */
  unit: string | null;
  legend: CategoricalLegend | NumericalLegend;
}

export interface DescritionResponse {
  description: string;
}

export interface H3GridInfo {
  /**
   * @minimum 0
   * @maximum 15
   */
  level: number;
  /**
   * @minimum 0
   * @maximum 15
   */
  h3_cells_resolution: number;
  h3_cells_count: number;
}

export interface ValidationError {
  loc: (string | number)[];
  msg: string;
  type: string;
}

export interface HTTPValidationError {
  detail?: ValidationError[];
}

export interface MultiDatasetMeta {
  /** Variables represented in this dataset. */
  datasets: DatasetMeta[];
  /** H3 related information. */
  h3_grid_info: H3GridInfo[];
}

export interface TableResultColumn {
  /** Column name */
  column: string;
  /** Check dataset metadata for type info */
  values: unknown[];
}

export interface TableResults {
  table: TableResultColumn[];
  cells: string[];
}

export type GridTileGridTileTileIndexGetParams = {
  /**
   * Column/s to include in the tile. If empty, it returns only cell indexes.
   */
  columns?: string[];
};

export type GridTileInAreaGridTileTileIndexPostParams = {
  /**
   * Column/s to include in the tile. If empty, it returns only cell indexes.
   */
  columns?: string[];
};

export type GridDatasetMetadataInAreaGridMetaPostParams = {
  /**
   * Tile level at which the query will be computed
   */
  level?: number;
  /**
   * Column/s to include in the tile. If empty, it returns only cell indexes.
   */
  columns?: string[];
};

export type ReadTableGridTablePostParams = {
  /**
   * Tile level at which the query will be computed
   */
  level: number;
  /**
   * Number of records.
   * @exclusiveMaximum 1000
   */
  limit?: number;
  /**
   * Prepend '-' to column name to make it descending
   */
  order_by: string[];
};
