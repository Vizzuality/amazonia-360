# Elastic Beanstalk extension to initialize per-environment database
#
# This runs on each deployment to ensure the database and user exist; it is
# idempotent, so it can be safely run multiple times without causing issues
# (but it will add a few seconds to deployment time).

files:
  "/opt/elasticbeanstalk/hooks/appdeploy/pre/01_init_database.sh":
    mode: "000755"
    owner: root
    group: root
    content: |
      #!/bin/bash
      set -e

      echo "=== Database Initialization Script ==="

      # Source EB environment variables
      # EB stores environment variables that can be accessed via get-config utility
      if [ -f /opt/elasticbeanstalk/bin/get-config ]; then
        echo "Loading environment variables from EB configuration..."

        # Get environment variables from EB
        export TF_DB_HOST=$(/opt/elasticbeanstalk/bin/get-config environment -k TF_DB_HOST 2>/dev/null || echo "")
        export TF_DB_PORT=$(/opt/elasticbeanstalk/bin/get-config environment -k TF_DB_PORT 2>/dev/null || echo "5432")
        export TF_DB_MASTER_USERNAME=$(/opt/elasticbeanstalk/bin/get-config environment -k TF_DB_MASTER_USERNAME 2>/dev/null || echo "")
        export TF_DB_MASTER_PASSWORD=$(/opt/elasticbeanstalk/bin/get-config environment -k TF_DB_MASTER_PASSWORD 2>/dev/null || echo "")
        export TF_DB_NAME=$(/opt/elasticbeanstalk/bin/get-config environment -k TF_DB_NAME 2>/dev/null || echo "")
        export TF_DB_USERNAME=$(/opt/elasticbeanstalk/bin/get-config environment -k TF_DB_USERNAME 2>/dev/null || echo "")
        export TF_DB_PASSWORD=$(/opt/elasticbeanstalk/bin/get-config environment -k TF_DB_PASSWORD 2>/dev/null || echo "")

        echo "Environment variables loaded from EB configuration"
      else
        echo "WARNING: get-config utility not found, using shell environment variables"
      fi

      echo "Starting database initialization..."

      # Check if required environment variables are set
      if [ -z "$TF_DB_HOST" ] || [ -z "$TF_DB_MASTER_USERNAME" ] || [ -z "$TF_DB_MASTER_PASSWORD" ]; then
        echo "ERROR: Required database environment variables not set"
        echo "Required: TF_DB_HOST, TF_DB_MASTER_USERNAME, TF_DB_MASTER_PASSWORD"
        exit 1
      fi

      if [ -z "$TF_DB_NAME" ] || [ -z "$TF_DB_USERNAME" ] || [ -z "$TF_DB_PASSWORD" ]; then
        echo "ERROR: Required application database variables not set"
        echo "Required: TF_DB_NAME, TF_DB_USERNAME, TF_DB_PASSWORD"
        exit 1
      fi

      # Install PostgreSQL client if not present
      # WARNING: On later versions of Amazon Linux, this package may not
      # exist anymore, but it seems that there is no generic `postgresql`
      # package in Amazon Linux as there is in Fedora, for example, so we
      # somehow need to use a package name with a specific version.
      # This may fail at some point in the future if redeploying with a
      # more recent Amazon Linux as base, so we'd need to adjust accordingly.
      PSQL_INSTALLED=false
      if ! command -v psql &> /dev/null; then
        echo "Installing PostgreSQL client..."
        yum install -y postgresql16
        PSQL_INSTALLED=true
      fi

      # Cleanup function to remove PostgreSQL client if we installed it
      cleanup_psql() {
        if [ "$PSQL_INSTALLED" = true ]; then
          echo "Cleaning up PostgreSQL client..."
          yum remove -y postgresql16 || true
          echo "Removing unused dependencies..."
          yum autoremove -y || true
        fi
      }

      # Set trap to cleanup on exit (success or failure)
      trap cleanup_psql EXIT

      # Validate inputs to prevent SQL injection
      # Database names and usernames should only contain alphanumeric, underscore, and hyphen
      validate_identifier() {
        local value="$1"
        local name="$2"
        if [[ ! "$value" =~ ^[a-zA-Z0-9_-]+$ ]]; then
          echo "ERROR: Invalid $name: '$value'. Must contain only alphanumeric characters, underscores, and hyphens."
          exit 1
        fi
      }

      # Validate passwords to prevent SQL injection
      # Uses an allow-list approach to ensure passwords only contain safe characters.
      # This matches the character set used in Terraform's random_password resources:
      # - Master password: !#$%&*()-_=+[]{}<>:?
      # - Per-instance password: alphanumeric only (special = false)
      # Importantly excludes dangerous characters like: single quote ('), double quote ("), semicolon (;), backslash (\), backtick (`)
      validate_password() {
        local value="$1"
        local name="$2"

        # Ensure password is not empty and has reasonable length
        if [ ${#value} -lt 8 ]; then
          echo "ERROR: Invalid $name. Password must be at least 8 characters long."
          exit 1
        fi

        # Use grep to verify password contains only allowed characters
        # grep -E uses extended regex, -v inverts match, -q is quiet
        if echo "$value" | grep -Evq '^[a-zA-Z0-9!#\$%&*()_=+\[\]{}<>:?]+$'; then
          echo "ERROR: Invalid $name. Contains characters outside the allowed set."
          echo "Allowed: alphanumeric and these special characters: !#\$%&*()_=+[]{}<>:?"
          echo "This validation matches our Terraform random_password configuration."
          exit 1
        fi
      }

      validate_identifier "$TF_DB_NAME" "database name"
      validate_identifier "$TF_DB_USERNAME" "username"
      validate_password "$TF_DB_MASTER_PASSWORD" "master password"
      validate_password "$TF_DB_PASSWORD" "application user password"

      echo "Database Host: $TF_DB_HOST"
      echo "Application Database: $TF_DB_NAME"
      echo "Application User: $TF_DB_USERNAME"

      # Function to execute SQL as master user
      # NOTE: This function uses direct string interpolation for SQL statements.
      # While this could theoretically be vulnerable to SQL injection, all values
      # used are controlled by our infrastructure team via Terraform/EB environment
      # variables, and identifiers are validated above to match ^[a-zA-Z0-9_-]+$
      # Usage: exec_sql "SQL statement"
      exec_sql() {
        local sql="$1"
        PGPASSWORD="$TF_DB_MASTER_PASSWORD" psql \
          -h "$TF_DB_HOST" \
          -p "${TF_DB_PORT:-5432}" \
          -U "$TF_DB_MASTER_USERNAME" \
          -d postgres \
          -t \
          -c "$sql" 2>&1
      }

      # Function to execute SQL in a specific database
      # NOTE: This function uses direct string interpolation (see note above)
      # Usage: exec_sql_in_db "dbname" "SQL statement"
      exec_sql_in_db() {
        local db="$1"
        local sql="$2"
        PGPASSWORD="$TF_DB_MASTER_PASSWORD" psql \
          -h "$TF_DB_HOST" \
          -p "${TF_DB_PORT:-5432}" \
          -U "$TF_DB_MASTER_USERNAME" \
          -d "$db" \
          -t \
          -c "$sql" 2>&1
      }

      echo "Checking database connectivity..."
      if ! exec_sql "SELECT 1;" > /dev/null; then
        echo "ERROR: Cannot connect to database"
        exit 1
      fi
      echo "Database connection successful"

      echo "Checking if user exists..."
      USER_EXISTS=$(exec_sql "SELECT 1 FROM pg_roles WHERE rolname = '$TF_DB_USERNAME';" | xargs)

      if [ "$USER_EXISTS" != "1" ]; then
        echo "Creating user: $TF_DB_USERNAME"
        # Password may contain special characters, so we use single quotes for the string literal
        exec_sql "CREATE USER \"$TF_DB_USERNAME\" WITH PASSWORD '$TF_DB_PASSWORD' LOGIN;" || {
          echo "ERROR: Failed to create user"
          exit 1
        }
        echo "User created successfully"
      else
        echo "User already exists: $TF_DB_USERNAME"
        echo "Updating password..."
        exec_sql "ALTER USER \"$TF_DB_USERNAME\" WITH PASSWORD '$TF_DB_PASSWORD';" || {
          echo "ERROR: Failed to update password"
          exit 1
        }
        echo "Password updated successfully"
      fi

      echo "Checking if database exists..."
      DB_EXISTS=$(exec_sql "SELECT 1 FROM pg_database WHERE datname = '$TF_DB_NAME';" | xargs)

      if [ "$DB_EXISTS" != "1" ]; then
        echo "Creating database: $TF_DB_NAME"
        # Grant role to master user temporarily to allow creating database with ownership
        exec_sql "GRANT \"$TF_DB_USERNAME\" TO \"$TF_DB_MASTER_USERNAME\";" || {
          echo "WARNING: Failed to grant role to master user (may already be granted)"
        }
        exec_sql "CREATE DATABASE \"$TF_DB_NAME\" OWNER \"$TF_DB_USERNAME\";" || {
          echo "ERROR: Failed to create database"
          exit 1
        }
        echo "Database created successfully"
      else
        echo "Database already exists: $TF_DB_NAME"
        echo "Ensuring correct ownership..."
        # Grant role to master user temporarily to allow altering database ownership
        exec_sql "GRANT \"$TF_DB_USERNAME\" TO \"$TF_DB_MASTER_USERNAME\";" || {
          echo "WARNING: Failed to grant role to master user (may already be granted)"
        }
        exec_sql "ALTER DATABASE \"$TF_DB_NAME\" OWNER TO \"$TF_DB_USERNAME\";" || {
          echo "WARNING: Failed to update database ownership (may already be correct)"
        }
      fi

      echo "Granting database privileges..."
      exec_sql "GRANT ALL PRIVILEGES ON DATABASE \"$TF_DB_NAME\" TO \"$TF_DB_USERNAME\";" || {
        echo "WARNING: Failed to grant database privileges (may already be granted)"
      }

      echo "Connecting to application database to set up schema permissions..."
      exec_sql_in_db "$TF_DB_NAME" "GRANT ALL ON SCHEMA public TO \"$TF_DB_USERNAME\";" || {
        echo "WARNING: Failed to grant schema privileges (may already be granted)"
      }

      # Grant privileges on existing tables and sequences
      exec_sql_in_db "$TF_DB_NAME" "GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO \"$TF_DB_USERNAME\";" || true
      exec_sql_in_db "$TF_DB_NAME" "GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO \"$TF_DB_USERNAME\";" || true

      echo "Setting default privileges for future objects..."
      exec_sql_in_db "$TF_DB_NAME" "ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO \"$TF_DB_USERNAME\";" || true
      exec_sql_in_db "$TF_DB_NAME" "ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO \"$TF_DB_USERNAME\";" || true

      echo "=== Database initialization complete ==="
      echo ""
      echo "Application can now connect using:"
      echo "  Host: $TF_DB_HOST"
      echo "  Port: ${TF_DB_PORT:-5432}"
      echo "  Database: $TF_DB_NAME"
      echo "  Username: $TF_DB_USERNAME"
      echo "  DATABASE_URI: postgresql://$TF_DB_USERNAME:<password>@$TF_DB_HOST:${TF_DB_PORT:-5432}/$TF_DB_NAME"

      exit 0

commands:
  01_set_execute_permissions:
    command: chmod +x /opt/elasticbeanstalk/hooks/appdeploy/pre/01_init_database.sh
